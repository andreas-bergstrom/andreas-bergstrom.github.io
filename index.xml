<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Andreas Bergström</title><link>https://andreasbergstrom.com/</link><description>Recent content on Andreas Bergström</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 28 Mar 2019 08:38:33 +0100</lastBuildDate><atom:link href="https://andreasbergstrom.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Master Python Dates</title><link>https://andreasbergstrom.com/posts/master-python-dates/</link><pubDate>Thu, 28 Mar 2019 08:38:33 +0100</pubDate><guid>https://andreasbergstrom.com/posts/master-python-dates/</guid><description>Master date and time handling in Python It might seem like a basic advice, but you will be suprised how much time you can save by simply learning how to properly work with dates. While this is a common task it is often not practiced enough that you really remember all the ins and outs of it. But it is really simple!
When dealing with dates you will want to use the datetime packages, which comes with both date and datetime.</description></item><item><title>Python Tips and Gotchas</title><link>https://andreasbergstrom.com/posts/python-gotchas-and-tips/</link><pubDate>Wed, 27 Mar 2019 17:24:57 +0100</pubDate><guid>https://andreasbergstrom.com/posts/python-gotchas-and-tips/</guid><description>This post is a work in progress and will expand over time.
Replace literals with constants in if-expressions Whenever you need to check the value of a basic data type, the most straight-forward solution is to use literals:
1 2 3 4 if direction == &amp;#39;up&amp;#39;: # ... elif direction == &amp;#39;down&amp;#39;: # ... This might seem like pythonic code, but its simplicity could bite you.</description></item><item><title>Python random name generator</title><link>https://andreasbergstrom.com/posts/python-random-name-generator/</link><pubDate>Wed, 20 Mar 2019 15:20:53 +0100</pubDate><guid>https://andreasbergstrom.com/posts/python-random-name-generator/</guid><description>Generates a random name-like string, uses a generator function to yield each letter.
Gist on Github
import string import random vowels = &amp;#39;aeiou&amp;#39; consonants = &amp;#39;bcdfghijklmnpqrstvwxz&amp;#39; def get_letter(last_letter=None): # Check if last letter generated was a consonant if last_letter: last_letter = &amp;#39;&amp;#39;.join(last_letter) last_letter_was_consonant = last_letter in consonants else: last_letter_was_consonant = False # If last letter was a vowel, make it 50% chance to generate a consonant if not last_letter_was_consonant and bool(random.</description></item><item><title>Comments in Hugo</title><link>https://andreasbergstrom.com/posts/comments-in-hugo/</link><pubDate>Wed, 06 Mar 2019 10:52:23 +0100</pubDate><guid>https://andreasbergstrom.com/posts/comments-in-hugo/</guid><description>This site is powered by Hugo, a static site generator for Hugo. It sits in the same category as Jekyll (Ruby), Pelican (Python), Jigsaw (PHP), Windersmith (Node) and Wyam (.Net Core), if you&amp;rsquo;re coming from any of those platforms.
I love the concept of handling content as raw markdown and keeping it version controlled with Git. But one thing I struggled to find a solution to was how to &amp;ldquo;comment out&amp;rdquo; chunks of content that shold not be rendered to HTML by Hugo, similarly to how you can comment out regular code.</description></item><item><title>argparse - modern Python command line arguments</title><link>https://andreasbergstrom.com/posts/python-argparse/</link><pubDate>Tue, 05 Mar 2019 21:10:21 +0100</pubDate><guid>https://andreasbergstrom.com/posts/python-argparse/</guid><description>If you search for information on how to write Python modules that accepts command line arguments, you are very likely to stumble upon sys.argv and getopt() and go with it. But since Python 3.2 there is a better alternative that requires less boilerplate and less re-inventing the wheel: argparse.
Just like getopt() argparse relies on sys.argv but it is more high-level and provides more functionality out of the box. At the core of argparse is the class ArgumentParser, which returns an object that you can use to create the argument interface.</description></item><item><title>About Andreas Bergström</title><link>https://andreasbergstrom.com/about-me/</link><pubDate>Mon, 04 Mar 2019 09:47:22 +0100</pubDate><guid>https://andreasbergstrom.com/about-me/</guid><description>Born in Sweden in the late 80&amp;rsquo;s I got my first computer in the early 90&amp;rsquo;s, an Intel 386 with MS-DOS. Having to start games like Retal and Lemmings from the command line was enough challenge at the time, but when I later upgraded to Windows 3.1 I actually started tinkering with the computer a bit more.
My friends were however already using Windows 95 and played games like Sim City 2000, Heroes of Might and Magic, Warcraft and Magic Carpet.</description></item><item><title>Python del vs assigning to None</title><link>https://andreasbergstrom.com/posts/python-del-vs-assign-none/</link><pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate><guid>https://andreasbergstrom.com/posts/python-del-vs-assign-none/</guid><description>Python utilizes garbage collection to free the developer from the hassle of manually handling allocating and de-allocating memory. But there are still some details that could suprise you unless you are aware of them.
Because even though the Python runtime will take care of memory management, sometimes developers will want to manually tell the garbage colletor that a variable is no longer needed. Either because they are doing some edge-case optimization and really know what they are doing or they think they are smart but have no idea what they are doing.</description></item></channel></rss>