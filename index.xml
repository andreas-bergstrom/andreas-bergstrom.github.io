<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Andreas Bergström</title><link>https://andreasbergstrom.com/</link><description>Recent content on Andreas Bergström</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 12 Jul 2019 06:31:39 +0100</lastBuildDate><atom:link href="https://andreasbergstrom.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Django Environment Variables with Decouple</title><link>https://andreasbergstrom.com/posts/django-decouple/</link><pubDate>Fri, 12 Jul 2019 06:31:39 +0100</pubDate><guid>https://andreasbergstrom.com/posts/django-decouple/</guid><description>An application&amp;rsquo;s configuration might seem like a no-brainer at first. It is just a bunch of variables that can be put in a regular code file, right? And if our local and production environments require different settings let us just throw in some if-statements, if it becomes cumbersome we can always pass some good old command line arguments when launching it. Wait did we just commit our secret key and Mailgun-credentials to source control?</description></item><item><title>Python Tips and Gotchas #4 - Understand truthy and falsy</title><link>https://andreasbergstrom.com/posts/python-gotchas-and-tips-4/</link><pubDate>Tue, 16 Apr 2019 18:21:37 +0100</pubDate><guid>https://andreasbergstrom.com/posts/python-gotchas-and-tips-4/</guid><description>Truthy and falsy are the ways values implicitly converts to booleans when used in if-expressions, and are different to the booleans True and False. Booleans work pretty much identical in every major programming language. But the workings of truthy and falsy are not. Javascript are infamous for being really messy and inconsistent with its truthy and falsy values, while Swift and C# simply does not allow any implicit conversion to booleans.</description></item><item><title>Python Tips and Gotchas #3 - Be more effecient with the REPL</title><link>https://andreasbergstrom.com/posts/python-gotchas-and-tips-3/</link><pubDate>Tue, 16 Apr 2019 16:21:37 +0100</pubDate><guid>https://andreasbergstrom.com/posts/python-gotchas-and-tips-3/</guid><description>The REPL is certainly one of Python&amp;rsquo;s most unique features. While there are other languages that also provides some kind of interactive prompt, none is as fleshed out as in Python. And while it is easy to get started with, there a few tips that will help you work faster.
Interactive execution of modules and packages Probably the most useful feature of the REPL is the ability to load modules and packages in interactive mode.</description></item><item><title>Python Tips and Gotchas #2 - Microseconds and accuracy in time.sleep()</title><link>https://andreasbergstrom.com/posts/python-gotchas-and-tips-2/</link><pubDate>Tue, 16 Apr 2019 14:21:37 +0100</pubDate><guid>https://andreasbergstrom.com/posts/python-gotchas-and-tips-2/</guid><description>The sleep function in the time module can be used to halt execution for a given number of seconds. But it is easy to miss that the argument can be a float as well. In other words, you can use microseconds and not just whole seconds:
1 2 import time time.sleep(0.05) This can be useful when you need to make a short pause but not necesseraly in seconds.</description></item><item><title>Using PyCharm scratch files with Django</title><link>https://andreasbergstrom.com/posts/pycharm-scratch-files-django/</link><pubDate>Tue, 02 Apr 2019 14:56:41 +0200</pubDate><guid>https://andreasbergstrom.com/posts/pycharm-scratch-files-django/</guid><description>Scratches are a great feature in PyCharm that are going to speed up your development and prototyping once you start using them. A scratch file is nothing more than a temporary file that lives outside of your regular project structure:
While the Django shell is great for trying out your code, it is not that comfortable to work with when you are writing large amounts of code. This is where scratch files comes handy, allowing you to use a regular file but without cluttering up your real codebase.</description></item><item><title>Python Tips and Gotchas #1 - Replace literals with constants in if-expressions</title><link>https://andreasbergstrom.com/posts/python-gotchas-and-tips/</link><pubDate>Sun, 31 Mar 2019 15:21:37 +0100</pubDate><guid>https://andreasbergstrom.com/posts/python-gotchas-and-tips/</guid><description>Whenever you need to check the value of a basic data type, the most straight-forward solution is to use literals:
1 2 3 4 if direction == &amp;#39;up&amp;#39;: # ... elif direction == &amp;#39;down&amp;#39;: # ... This might seem like pythonic code, but its simplicity could bite you. If you have a lot of conditions and perhaps in multiple locations in your code, what happens if you mistype any of those string literals?</description></item><item><title>Master date and time handling in Python</title><link>https://andreasbergstrom.com/posts/master-python-dates/</link><pubDate>Thu, 28 Mar 2019 08:38:33 +0100</pubDate><guid>https://andreasbergstrom.com/posts/master-python-dates/</guid><description>It might seem like a basic advice, but you will be suprised how much time you can save by simply learning how to properly work with dates. While this is a common task it is often not practiced enough that you really remember all the ins and outs of it. But it is really simple!
When dealing with dates you will want to use the datetime packages, which comes with both date and datetime.</description></item><item><title>Python random name generator</title><link>https://andreasbergstrom.com/posts/python-random-name-generator/</link><pubDate>Wed, 20 Mar 2019 15:20:53 +0100</pubDate><guid>https://andreasbergstrom.com/posts/python-random-name-generator/</guid><description>Generates a random name-like string, uses a generator function to yield each letter.
Gist on Github
import string import random vowels = &amp;#39;aeiou&amp;#39; consonants = &amp;#39;bcdfghijklmnpqrstvwxz&amp;#39; def get_letter(last_letter=None): # Check if last letter generated was a consonant if last_letter: last_letter = &amp;#39;&amp;#39;.join(last_letter) last_letter_was_consonant = last_letter in consonants else: last_letter_was_consonant = False # If last letter was a vowel, make it 50% chance to generate a consonant if not last_letter_was_consonant and bool(random.</description></item><item><title>Comments in Hugo</title><link>https://andreasbergstrom.com/posts/comments-in-hugo/</link><pubDate>Wed, 06 Mar 2019 10:52:23 +0100</pubDate><guid>https://andreasbergstrom.com/posts/comments-in-hugo/</guid><description>This site is powered by Hugo, a static site generator for Hugo. It sits in the same category as Jekyll (Ruby), Pelican (Python), Jigsaw (PHP), Windersmith (Node) and Wyam (.Net Core), if you&amp;rsquo;re coming from any of those platforms.
I love the concept of handling content as raw markdown and keeping it version controlled with Git. But one thing I struggled to find a solution to was how to &amp;ldquo;comment out&amp;rdquo; chunks of content that shold not be rendered to HTML by Hugo, similarly to how you can comment out regular code.</description></item><item><title>Better Python Command Line Arguments with argparse</title><link>https://andreasbergstrom.com/posts/python-argparse/</link><pubDate>Tue, 05 Mar 2019 21:10:21 +0100</pubDate><guid>https://andreasbergstrom.com/posts/python-argparse/</guid><description>If you search for information on how to write Python modules that accepts command line arguments, you are very likely to stumble upon sys.argv and getopt() and go with it. But since Python 3.2 there is a better alternative that requires less boilerplate and less re-inventing the wheel: argparse.
Just like getopt() argparse relies on sys.argv but it is more high-level and provides more functionality out of the box. At the core of argparse is the class ArgumentParser, which returns an object that you can use to create the argument interface.</description></item><item><title>About Andreas Bergström</title><link>https://andreasbergstrom.com/about-me/</link><pubDate>Mon, 04 Mar 2019 09:47:22 +0100</pubDate><guid>https://andreasbergstrom.com/about-me/</guid><description>Born in Sweden in the late 80&amp;rsquo;s I got my first computer in the early 90&amp;rsquo;s, an Intel 386 with MS-DOS. Having to start games like Retal and Lemmings from the command line was enough challenge at the time, but when I later upgraded to Windows 3.1 I actually started tinkering with the computer a bit more.
My friends were however already using Windows 95 and played games like Sim City 2000, Heroes of Might and Magic, Warcraft and Magic Carpet.</description></item><item><title>Python del vs assigning to None</title><link>https://andreasbergstrom.com/posts/python-del-vs-assign-none/</link><pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate><guid>https://andreasbergstrom.com/posts/python-del-vs-assign-none/</guid><description>Python utilizes garbage collection to free the developer from the hassle of manually handling allocating and de-allocating memory. But there are still some details that could suprise you unless you are aware of them.
Because even though the Python runtime will take care of memory management, sometimes developers will want to manually tell the garbage colletor that a variable is no longer needed. Either because they are doing some edge-case optimization and really know what they are doing or they think they are smart but have no idea what they are doing.</description></item></channel></rss>